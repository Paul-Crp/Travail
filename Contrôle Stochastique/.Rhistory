# Diminution des décès : action 2
q3 <- NULL
for (i in 0:M) {
q3 <- c(q3, transition_density(i, 3))
}
Q[, , 3] <- matrix(q3, nrow = (M + 1), byrow = TRUE)
N <- 20
rec <- matrix(c(0, -0.1, -0.2), nrow = 1) # Récompense instantanée
V <- matrix(-1, nrow = M + 1, ncol = N + 1)
maximiseur <- matrix(-1, nrow = M + 1, ncol = N)
# On remplit les deux matrices de bases de -1 pour faciliter la lecture
# et ne pas confondre un 0 de base avec l'action 0.
V[, 1] <- (0:M) # Récompense terminale
V[1, 1] <- -5   # De même
for (n in 1:N) {
for (k in 1:(M + 1)) {
if (k <= 2^(N - n + 1) + 1) {
tmp <- NULL
tmp <- rec + V[, n] %*% Q[k, , ]
v <- max(tmp)
f <- which.max(tmp)
V[k, n + 1] <- v
maximiseur [k, n] <- f - 1
}
}
}
M=70
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 10000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 100) {
a <- a + 1
r <- c(r, p[i])
}
}
b <- a
while (b / a > 0.0001) {
b <- a
for (i in 1:a) {
if (r[i] < M) {
b <- b - 1
}
}
M <- M + 1
}
M=70
proba_b <- c(0.45, 0.5,  0.45)
proba_d <- c(0.45, 0.45, 0.35)
transition_density  <-  function(population, action) {
result <- convolve(dbinom(0:population, population, proba_b[action]),
dbinom(0:population, population, proba_d[action]), type = "open")
# Fait le produit de convolution des binomiales
result <- result[1:(M + 1)] # On s'assure que le vecteur fait la bonne taille
result[is.na(result)] <- 0  # et on replace les NA par des 0 si besoin.
result[M + 1] <- 1 - sum(result[1:M])
# On place tout le poids de la probabilité
# de toutes les populations supérieur à M à la fin.
result # Renvoie le résultat
}
# Matrices de transition
Q <- array(0, dim <- c((M + 1), (M + 1), 3))
# Ne rien faire : action 0
q1 <- NULL
for (i in 0:M) {
q1 <- c(q1, transition_density(i, 1))
} # On crée M+1 vecteurs de taille M+1 les uns à la suite des autres,
# chacun correspondant à une loi de probabilité pour un nombre d'oiseaux en particulier.
Q[, , 1] <- matrix(q1, nrow = (M + 1), byrow = TRUE)
# On remplit ensuite la matrice avec le vecteur qu'on découpe en M+1 morceaux.
# Augmentation de la fécondité : action 1
q2 <- NULL
for (i in 0:M) {
q2 <- c(q2, transition_density(i, 2))
}
Q[, , 2] <- matrix(q2, nrow = (M + 1), byrow = TRUE)
# Diminution des décès : action 2
q3 <- NULL
for (i in 0:M) {
q3 <- c(q3, transition_density(i, 3))
}
Q[, , 3] <- matrix(q3, nrow = (M + 1), byrow = TRUE)
N <- 20
rec <- matrix(c(0, -0.1, -0.2), nrow = 1) # Récompense instantanée
V <- matrix(-1, nrow = M + 1, ncol = N + 1)
maximiseur <- matrix(-1, nrow = M + 1, ncol = N)
# On remplit les deux matrices de bases de -1 pour faciliter la lecture
# et ne pas confondre un 0 de base avec l'action 0.
V[, 1] <- (0:M) # Récompense terminale
V[1, 1] <- -5   # De même
for (n in 1:N) {
for (k in 1:(M + 1)) {
if (k <= 2^(N - n + 1) + 1) {
tmp <- NULL
tmp <- rec + V[, n] %*% Q[k, , ]
v <- max(tmp)
f <- which.max(tmp)
V[k, n + 1] <- v
maximiseur [k, n] <- f - 1
}
}
}
View(V)
M=199
proba_b <- c(0.45, 0.5,  0.45)
proba_d <- c(0.45, 0.45, 0.35)
transition_density  <-  function(population, action) {
result <- convolve(dbinom(0:population, population, proba_b[action]),
dbinom(0:population, population, proba_d[action]), type = "open")
# Fait le produit de convolution des binomiales
result <- result[1:(M + 1)] # On s'assure que le vecteur fait la bonne taille
result[is.na(result)] <- 0  # et on replace les NA par des 0 si besoin.
result[M + 1] <- 1 - sum(result[1:M])
# On place tout le poids de la probabilité
# de toutes les populations supérieur à M à la fin.
result # Renvoie le résultat
}
# Matrices de transition
Q <- array(0, dim <- c((M + 1), (M + 1), 3))
# Ne rien faire : action 0
q1 <- NULL
for (i in 0:M) {
q1 <- c(q1, transition_density(i, 1))
} # On crée M+1 vecteurs de taille M+1 les uns à la suite des autres,
# chacun correspondant à une loi de probabilité pour un nombre d'oiseaux en particulier.
Q[, , 1] <- matrix(q1, nrow = (M + 1), byrow = TRUE)
# On remplit ensuite la matrice avec le vecteur qu'on découpe en M+1 morceaux.
# Augmentation de la fécondité : action 1
q2 <- NULL
for (i in 0:M) {
q2 <- c(q2, transition_density(i, 2))
}
Q[, , 2] <- matrix(q2, nrow = (M + 1), byrow = TRUE)
# Diminution des décès : action 2
q3 <- NULL
for (i in 0:M) {
q3 <- c(q3, transition_density(i, 3))
}
Q[, , 3] <- matrix(q3, nrow = (M + 1), byrow = TRUE)
N <- 20
rec <- matrix(c(0, -0.1, -0.2), nrow = 1) # Récompense instantanée
V <- matrix(-1, nrow = M + 1, ncol = N + 1)
maximiseur <- matrix(-1, nrow = M + 1, ncol = N)
# On remplit les deux matrices de bases de -1 pour faciliter la lecture
# et ne pas confondre un 0 de base avec l'action 0.
V[, 1] <- (0:M) # Récompense terminale
V[1, 1] <- -5   # De même
for (n in 1:N) {
for (k in 1:(M + 1)) {
if (k <= 2^(N - n + 1) + 1) {
tmp <- NULL
tmp <- rec + V[, n] %*% Q[k, , ]
v <- max(tmp)
f <- which.max(tmp)
V[k, n + 1] <- v
maximiseur [k, n] <- f - 1
}
}
}
View(V)
View(maximiseur)
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 1000000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
max(p)
for (i in 1:nb_boucles) {
if (p[i] > 100) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
for (i in 1:a) {
if (r[i] < M) {
b <- b - 1
}
}
M <- M + 1
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
print(rowMeans(p) + 1.96 * sqrt(v))
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
for (i in 1:a) {
if (r[i] < M) {
b <- b - 1
}
}
M <- M + 1
}
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 1000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
for (i in 1:a) {
if (r[i] < M) {
b <- b - 1
}
}
M <- M + 1
}
p[168]
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 10000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
for (i in 1:a) {
if (r[i] < M) {
b <- b - 1
}
}
M <- M + 1
}
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 10000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
M <- M + 1
for (i in 1:a) {
if (r[i] < M) {
b <- b - 1
}
}
}
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 10000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
M <- M + 1
for (i in 1:a) {
if (r[i] <= M) {
b <- b - 1
}
}
}
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 100000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
M <- M + 1
for (i in 1:a) {
if (r[i] <= M) {
b <- b - 1
}
}
}
# Variables de bases, inutile de calculer les coûts.
nb_annees <- 20
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 100000
p <- matrix(nrow = 1, ncol = nb_boucles)
a <- 0
r <- c()
M <- 0
for (ii in 1:nb_boucles) {
nb_oiseaux <- 2
for (i in 2:(nb_annees + 1)) {
if (nb_oiseaux != 0) {
for (x in 1:nb_oiseaux) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < proba_d) {
nb_oiseaux <- nb_oiseaux - 1
}
if (b < proba_b) {
nb_oiseaux <- nb_oiseaux + 1
}
}
}
}
p[1, ii] <- nb_oiseaux
}
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
r <- c(r, p[i])
}
}
max <- max(p)
b <- a
while (b / a > 0.0001) {
b <- a
M <- M + 1
for (i in 1:a) {
if (r[i] <= M) {
b <- b - 1
}
}
}
