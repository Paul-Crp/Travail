d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
}
c <- c - alpha2
}
# On ajoute la récompense finale
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
p[1, ii] <- c
p[2, ii] <- nb_piafs
# On rajoute le ii-ème gain final à la ii-ème place de la matrice.
}
print("Estimation du gain:")
rowMeans(p)
print(rowMeans(p) - 1.96 * sqrt(v))
print(rowMeans(p) + 1.96 * sqrt(v))
v <- (mean(p^2) - mean(p)^2) / (nb_boucles - 1)
# On ne multiplie pas par "nb_boucles" car on le divise par cette même quantité dans le calcul de l'IC
print(rowMeans(p) - 1.96 * sqrt(v))
print(rowMeans(p) + 1.96 * sqrt(v))
install.packages("Metrics")
library(Metrics)
knitr::opts_chunk$set(echo = TRUE)
data(nottem)
plot.ts(nottem, xlab='temps', ylab='température')
fit <- decompose(nottem)
plot(fit)
fit2 <- decompose(nottem, type = "multiplicative")
plot(fit2)
monthplot(nottem)
nott_a = window(nottem, end=c(1936,12))
nott_v = window(nottem, start=c(1937,1))
acf(nott_a, lag.max=40,main="")
acf(ts(nott_a),type="correlation",lag.max=40,main="") #(les deux sont pareils)
#pas stationnaire car "On observe que l’ACF présente des pics aux retards multiples de 12 qui ne s’atténuent que très lentement : c’est le signe d’une non-stationnarité saisonnière."
pacf(ts(nott_a),lag.max=40,main="") #
acf(diff(ts(nott_a),12),type="correlation",lag.max=40,main="") #Les autocorrélations de la série différenciée à l’ordre 12 présente un pic à l’ordre 12 et une valeur non nulle en 24 puis une forte atténuation : caractéristique d’une saisonnalité.
pacf(diff(ts(nott_a),12),lag.max=40,main="") #Le PACF de la série différenciée à l’ordre 12 présente un pic à l’ordre 12 et à l’ordre 13, ainsi qu’à l’ordre 1.
#Question 2 SARIMA(p,0,q)(P,1,Q) (p pour AR, q pour MA) (PACF pour AR)
# on peut estimer à max 1, max 1, max 2, max 2 (Tout ce lit sur les auto_co différenciés. les GRANDS se lisent sur les multiples de la saisonnalité (12 ici) et les petits se lisent sont les barres non significativement ignorables - par exemple le 13 ici car le c'est 1 + le 12 (PACF))
library(forecast)
fitm = arima(nott_a,order=c(1,0,0), seasonal=list(order=c(2,1,0), period=12))
summary(fitm)
fitmm= Arima(nott_a,order=c(1,0,0), seasonal=list(order=c(2,1,0), period=12),include.drift=TRUE)
summary(fitmm)
Box.test(fitm$residuals,lag=c(5))
Box.test(fitm$residuals,lag=c(10))
Box.test(fitm$residuals,lag=c(15))
Box.test(fitm$residuals,lag=c(20))
shapiro.test(fitm$residuals)
qqnorm(fitm$residuals/sqrt(fitm$sigma2))
abline(a=0,b=1,col="red")
fitm2 = arima(nott_a,order=c(1,0,0), seasonal=list(order=c(2,1,1), period=12))
summary(fitm2)
fitmm2 = Arima(nott_a,order=c(1,0,0), seasonal=list(order=c(2,1,1), period=12),include.drift=TRUE)
summary(fitmm2)
auto.arima(nott_a,d=0,D=1,max.p=2,max.q=2,seasonal=TRUE)-> fit_auto
summary(fit_auto)
acf(fit_auto$residuals)
pacf(fit_auto$residuals)
pred.sarima = forecast(fitm, h=36)
pred.sarima2 = forecast(fitm2, h=36)
pred.sarima_auto = forecast(fit_auto, h=36)
plot(pred.sarima,main="Prévision de de 1937 à 1939")
points(nott_v,col="darkgreen",lwd=2,type="l")
plot(pred.sarima,main="Prévision de de 1937 à 1939")
points(nott_v,col="darkgreen",lwd=2,type="l")
plot(pred.sarima_auto,main="Prévision de de 1937 à 1939")
points(nott_v,col="darkgreen",lwd=2,type="l")
tnupp = ts(pred.sarima$upper[,1],start=c(1937,1),frequency=12)
tnlow = ts(pred.sarima$lower[,1],start=c(1937,1),frequency=12)
plot(window(pred.sarima$mean,start=c(1937,1)),col="darkblue",lwd=2,main="Prévision de de 1937")
points(nott_v,col="darkgreen",lwd=2,type="l")
points(tnupp, col="darkblue",lty=2, type="l")
points(tnlow, col="darkblue",lty=2, type="l")
a=0
for (h in 1:36) {
a=a+(((pred.sarima$mean[h])-nott_v[h])^2)
}
a=a/36
a
a1=0
for (h in 1:36) {
a1=a1+(((pred.sarima2$mean[h])-nott_v[h])^2)
}
a1=a1/36
a1
a2=0
for (h in 1:36) {
a2=a2+(((pred.sarima_auto$mean[h])-nott_v[h])^2)
}
a2=a2/36
a2
library(Metrics)
rmse(nott_v, pred.sarima$mean)
rmse(nott_v, pred.sarima2$mean)
rmse(nott_v, pred.sarima_auto$mean)
pred.sarima = forecast(fitm, h=36)
pred.sarima2 = forecast(fitm2, h=36)
pred.sarimaa2 = forecast(fitmm2, h=36)
pred.sarima_auto = forecast(fit_auto, h=36)
a=0
for (h in 1:36) {
a=a+(((pred.sarima$mean[h])-nott_v[h])^2)
}
a=a/36
a
a1=0
for (h in 1:36) {
a1=a1+(((pred.sarima2$mean[h])-nott_v[h])^2)
}
a1=a1/36
a1
a2=0
for (h in 1:36) {
a2=a2+(((pred.sarima_auto$mean[h])-nott_v[h])^2)
}
a2=a2/36
a2
library(Metrics)
rmse(nott_v, pred.sarima$mean)
rmse(nott_v, pred.sarimaa2$mean)
rmse(nott_v, pred.sarima_auto$mean)
a=0
for (h in 1:36) {
a=a+(((pred.sarima$mean[h])-nott_v[h])^2)
}
a=a/36
a
a1=0
for (h in 1:36) {
a1=a1+(((pred.sarima2$mean[h])-nott_v[h])^2)
}
a1=a1/36
a1
a2=0
for (h in 1:36) {
a2=a2+(((pred.sarima_auto$mean[h])-nott_v[h])^2)
}
a2=a2/36
a2
library(Metrics)
rmse(nott_v, pred.sarima$mean)
rmse(nott_v, pred.sarima2$mean)
rmse(nott_v, pred.sarimaa2$mean)
rmse(nott_v, pred.sarima_auto$mean)
v <- (mean(p^2) - mean(p)^2) / (nb_boucles - 1)
# On ne multiplie pas par "nb_boucles" car on le divise par cette même quantité dans le calcul de l'IC.
rowMeans(p)
#Variables de bases
nb_piafs <- 2
nb_annees <- 20
c <- 0
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.45
proba_b <- 0.45
nb_boucles <- 100000
p <- matrix(nrow = 2, ncol = nb_boucles)
# On crée une matrice à 2 lignes et autant de colonnes que nécessaire,
# la première pour le coût, la seconde pour le nombre d'oiseaux au bout de 20 ans.
for (ii in 1:nb_boucles) {
nb_piafs <- 2
c <- 0
# Ces variables ont besoin d'être remises à 0 à chaque nouvelle boucle et on retire les historiques.
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
}
}
# On ajoute la récompense finale
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
p[1, ii] <- c
p[2, ii] <- nb_piafs
# On rajoute le ii-ème gain final et nombre d'oiseaux à la ii-ème place de la matrice.
}
print("Estimation du gain:")
rowMeans(p)
a <- 0
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
}
}
a <- 0
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
}
}
a
p
rowMeans(p)
mean(p)^2)
mean(p)^2
summary(p[1,])
summary(p[,1])
View(p)
v[1]=0
v=c(0)
v[1] <- (mean((p[1,])^2) - mean(p[1,])^2) / (nb_boucles - 1)
v[2] <- (mean((p[2,])^2) - mean(p[2,])^2) / (nb_boucles - 1)
# On ne multiplie pas par "nb_boucles" car on le divise par cette même quantité dans le calcul de l'IC.
print(rowMeans(p) - 1.96 * sqrt(v))
print(rowMeans(p) + 1.96 * sqrt(v))
-1.56579+0.00039
-1.56579+1.96*sqrt(0.00039)
-1.56579-1.96*sqrt(0.00039)
1.99911-1.96*sqrt(0.00039)
1.99911-1.96*sqrt(0.000196)
knitr::opts_chunk$set(echo = TRUE)
#Variables de bases
nb_piafs <- 2
nb_annees <- 20
c <- 0
historique_nb_piafs <- c(nb_piafs)
historique_c <- c(c)
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.45
proba_b <- 0.45
# On fait la boucle sur le nombre d'années avec 2 nouvelles lois uniformes pour chaque piafs, chaque jours
# ainsi une actualisation du nombre d'oiseaux.
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
}
historique_nb_piafs[i] <- nb_piafs
historique_c[i] <- c
}
# On ajoute la récompense finale
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
historique_c[nb_annees + 2] <- c
par(mfrow <- c(1, 2))
plot(c(0:nb_annees), historique_nb_piafs, type = "b")
plot(c(0:(nb_annees + 1)), historique_c, type = "b")
#Variables de bases
nb_piafs <- 2
nb_annees <- 20
c <- 0
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.45
proba_b <- 0.45
nb_boucles <- 100000
p <- matrix(nrow = 2, ncol = nb_boucles)
# On crée une matrice à 2 lignes et autant de colonnes que nécessaire,
# la première pour le coût, la seconde pour le nombre d'oiseaux au bout de 20 ans.
for (ii in 1:nb_boucles) {
nb_piafs <- 2
c <- 0
# Ces variables ont besoin d'être remises à 0 à chaque nouvelle boucle et on retire les historiques.
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
}
}
# On ajoute la récompense finale
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
p[1, ii] <- c
p[2, ii] <- nb_piafs
# On rajoute le ii-ème gain final et nombre d'oiseaux à la ii-ème place de la matrice.
}
print("Estimation du gain:")
rowMeans(p)
v=c(0)
v[1] <- (mean((p[1,])^2) - mean(p[1,])^2) / (nb_boucles - 1)
v[2] <- (mean((p[2,])^2) - mean(p[2,])^2) / (nb_boucles - 1)
# On ne multiplie pas par "nb_boucles" car on le divise par cette même quantité dans le calcul de l'IC.
print("IC")
print(rowMeans(p) - 1.96 * sqrt(v))
print(rowMeans(p) + 1.96 * sqrt(v))
a <- 0
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
}
}
a
nb_piafs <- 2
nb_annees <- 20
c <- 0
historique_nb_piafs <- c(nb_piafs)
historique_c <- c(c)
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.45
proba_b <- 0.5 #On change la probabilité de naissance.
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
c <- c - alpha1
}
historique_nb_piafs[i] <- nb_piafs
historique_c[i] <- c
}
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
historique_c[nb_annees + 2] <- c
par(mfrow <- c(1, 2))
plot(c(0:nb_annees), historique_nb_piafs, type = "b")
plot(c(0:(nb_annees + 1)), historique_c, type = "b")
nb_piafs <- 2
nb_annees <- 20
c <- 0
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.45
proba_b <- 0.5
nb_boucles <- 100000
p <- matrix(nrow = 2, ncol = nb_boucles)
for (ii in 1:nb_boucles) {
nb_piafs <- 2
c <- 0
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
}
c <- c - alpha1
}
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
p[1, ii] <- c
p[2, ii] <- nb_piafs
}
print("Estimation du gain:")
rowMeans(p)
v=c(0)
v[1] <- (mean((p[1,])^2) - mean(p[1,])^2) / (nb_boucles - 1)
v[2] <- (mean((p[2,])^2) - mean(p[2,])^2) / (nb_boucles - 1)
# On ne multiplie pas par "nb_boucles" car on le divise par cette même quantité dans le calcul de l'IC.
print("IC")
print(rowMeans(p) - 1.96 * sqrt(v))
print(rowMeans(p) + 1.96 * sqrt(v))
a <- 0
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
}
}
nb_piafs <- 2
nb_annees <- 20
c <- 0
historique_nb_piafs <- c(nb_piafs)
historique_c <- c(c)
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.35 #On change la probabilité de décès
proba_b <- 0.45
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
c <- c - alpha2
}
historique_nb_piafs[i] <- nb_piafs
historique_c[i] <- c
}
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
historique_c[nb_annees + 2] <- c
par(mfrow <- c(1, 2))
plot(c(0:nb_annees), historique_nb_piafs, type = "b")
plot(c(0:(nb_annees + 1)), historique_c, type = "b")
nb_piafs <- 2
nb_annees <- 20
c <- 0
alpha0 <- 5
alpha1 <- 0.1
alpha2 <- 0.2
proba_d <- 0.35
proba_b <- 0.45
nb_boucles <- 100000
p <- matrix(nrow = 2, ncol = nb_boucles)
for (ii in 1:nb_boucles) {
nb_piafs <- 2
c <- 0
for (i in 2:(nb_annees + 1)) {
if (nb_piafs != 0) {
for (x in 1:nb_piafs) {
d <- runif(1, min = 0, max = 1)
b <- runif(1, min = 0, max = 1)
if (d < dbinom(x = 1, size = 1, prob = proba_d)) {
nb_piafs <- nb_piafs - 1
}
if (b < dbinom(x = 1, size = 1, prob = proba_b)) {
nb_piafs <- nb_piafs + 1
}
}
}
c <- c - alpha2
}
if (nb_piafs == 0) {
c <- c - alpha0
} else {
c <- c + nb_piafs
}
p[1, ii] <- c
p[2, ii] <- nb_piafs
}
print("Estimation du gain:")
rowMeans(p)
v=c(0)
v[1] <- (mean((p[1,])^2) - mean(p[1,])^2) / (nb_boucles - 1)
v[2] <- (mean((p[2,])^2) - mean(p[2,])^2) / (nb_boucles - 1)
# On ne multiplie pas par "nb_boucles" car on le divise par cette même quantité dans le calcul de l'IC.
print("IC")
print(rowMeans(p) - 1.96 * sqrt(v))
print(rowMeans(p) + 1.96 * sqrt(v))
a <- 0
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
}
}
a <- 0
for (i in 1:nb_boucles) {
if (p[i] > 0) {
a <- a + 1
}
}
a
